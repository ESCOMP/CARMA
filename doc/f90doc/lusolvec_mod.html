<HTML>
<HEAD>
   <TITLE> module lusolvec_mod (generated by f90doc) </TITLE>
</HEAD>
<H1> Module lusolvec_mod </H1>
<PRE>module lusolvec_mod

        ! Uses
    use <A HREF="carma_precision_mod.html">carma_precision_mod</A>
    use <A HREF="carma_enums_mod.html">carma_enums_mod</A>
    use <A HREF="carma_constants_mod.html">carma_constants_mod</A>
    use <A HREF="carma_types_mod.html">carma_types_mod</A>
    use <A HREF="carmastate_mod.html">carmastate_mod</A>
    use <A HREF="carma_mod.html">carma_mod</A>

        ! Subroutines and functions
    public subroutine <A HREF="lusolvec_mod.html#subroutine_ludcmpc">LUDCMPC</A> (A, N, numP, INDX, D)
    public subroutine <A HREF="lusolvec_mod.html#subroutine_lubksbc">LUBKSBC</A> (A, N, numP, INDX, B)

end module lusolvec_mod
</PRE>
 this module: lusolvec_mod   Numerical solution of a set of linear
                             Equations / a matrix equation A * x = b
                             using LU decomposition, matrix A and
                             vectors b and x being double complex,
                             and inversion of A.
 ******************************************************************
 Usage:
 ====== 
 given a complex matrix A, a right hand side vector b and a 
 matrix equation      A * x = b      to solve for vector x.
<P>
 First, call LUDCMPC(A,N,numP,INDX,D). The original Matrix A is lost   
 and substituted by its LU decomposition.                            
<P>
 Second, call LUBKSBC(A,N,numP,INDX,B). The original right-hand-side   
 vector ib in B is lost and replaced/returned as the solution        
 vector x  ( x(i) = B(i) ).                                          
 Use same kind of call to solve for successive right-hand-sides.     
<P>
 For Inversion of matrix A, call LUBKSBC() subsequently for each     
 column vector:                                                      
   1) Initialize matrix AINV(i,j) to be equal to the                 
      identity matrix (AINV(i,j)=1 for i=j; =0 otherwise)            
   2) DO jj=1,n                                                      
         CALL LUBKSBC(A,N,numP,INDX,AINV(1,jj))                        
      END DO                                                         
 (see textbook for further details).                                 
 ****************************************************************** 

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_ludcmpc"><H3>LUDCMPC</H3></A>
<PRE>public subroutine LUDCMPC (A, N, numP, INDX, D)
    complex (kind=f), dimension (numP,numP) :: A
    integer :: N
    integer :: numP
    integer, dimension (N) :: INDX
    real (kind=f) :: D
end subroutine LUDCMPC
</PRE>
 SUBROUTINE LUDCMPC(A,N,numP,INDX,D)                                   
<P>
 Given a general complex matrix A, this routine replaces it by its   
 LU decomposition of a rowwise permutation of itself.                
 This routine is used in combination with LUBKSBC(), a complex       
 extension of the routine LUBKSB() (DOUBLE COMPLEX).                 
 For further details, refer to textbook (see below).                 
<P>
 Source: Own adaption/extension to complex matrix of the             
         Subroutine LUDCMP() taken from                              
         Press et al, "Numerical Recipes in Fortran"                 
         The adaption follows the statements given in section 2.3    
         of the textbook "N.R. in C", following Eq.(2.3.16):         
         <UL>
         <LI>  definition of variables, vector and matrix elements       
           as complex variables (use of complex arithmetic does      
           not necessitate any adaption in fortran).                 
         <LI>  complex modulus instead of absolute values in the         
           construction of the vector vv and in the search for the   
           largest pivot elements.                                   
         </UL>
 ******************************************************************  
 Version: 28.08.2000                                                 
 ******************************************************************
<A NAME="subroutine_lubksbc"><H3>LUBKSBC</H3></A>
<PRE>public subroutine LUBKSBC (A, N, numP, INDX, B)
    complex (kind=f), dimension (numP,numP) :: A
    integer :: N
    integer :: numP
    integer, dimension (N) :: INDX
    complex (kind=f), dimension (N) :: B
end subroutine LUBKSBC
</PRE>
 SUBROUTINE LUBKSBC(A,N,numP,INDX,B)
<P>
 Solution of the set of linear equations A' * x = b where 
 A is input not as the original matrix, but as a LU decomposition 
 of some original matrix A' as determined by the subroutine
 LUDCMPC() (matrix and vectors being of type DOUBLE COMPLEX). 
 INDX() is input as the permutation vactor returned by LUDCMPC().
 B() is input as the right hand side vector b of the Eqn. to solve
 and returns with the solution vector x. 
 A, N and INDX are not modified by this routine and can be left in
 place for successive calls with different right-hand-sides b.
 For further details, refer to textbook (see below).
<P>
 Source: Own adaption/extension to complex matrix of the
         Subroutine LUBKSB() taken from
         Press et al, "Numerical Recipes in Fortran"
         The adaption follows the statements given in section 2.3
         of the textbook "N.R. in C", following Eq.(2.3.16).
 ******************************************************************
 Version: 28.08.2000
 ******************************************************************
</HTML>
