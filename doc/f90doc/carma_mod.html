<HTML>
<HEAD>
   <TITLE> module carma_mod (generated by f90doc) </TITLE>
</HEAD>
<H1> Module carma_mod </H1>
<PRE>module carma_mod

        ! Uses
    use <A HREF="carma_precision_mod.html">carma_precision_mod</A>
    use <A HREF="carma_enums_mod.html">carma_enums_mod</A>
    use <A HREF="carma_constants_mod.html">carma_constants_mod</A>
    use <A HREF="carma_types_mod.html">carma_types_mod</A>

        ! Subroutines and functions
    public subroutine <A HREF="carma_mod.html#subroutine_carma_create">CARMA_Create</A> (carma, NBIN, NELEM, NGROUP, NSOLUTE, NGAS, NWAVE, rc, LUNOPRT, wave, dwave, do_wave_emit, NREFIDX)
    public subroutine <A HREF="carma_mod.html#subroutine_carma_initialize">CARMA_Initialize</A> (carma, rc, do_cnst_rlh, do_coag, do_detrain, do_fixedinit, do_grow, do_incloud, do_explised, do_print_init, do_substep, do_thermo, do_vdiff, do_vtran, do_drydep, vf_const, minsubsteps, maxsubsteps, maxretries, conmax, do_pheat, do_pheatatm, dt_threshold, cstick, gsticki, gstickl, tstick, do_clearsky, do_partialinit, do_coremasscheck, sulfnucl_method)
    private subroutine <A HREF="carma_mod.html#subroutine_carma_initializegrowth">CARMA_InitializeGrowth</A> (carma, rc)
    private subroutine <A HREF="carma_mod.html#subroutine_carma_initializeoptics">CARMA_InitializeOptics</A> (carma, rc)
    private subroutine <A HREF="carma_mod.html#subroutine_carma_initializethermo">CARMA_InitializeThermo</A> (carma, rc)
    private subroutine <A HREF="carma_mod.html#subroutine_carma_initializevertical">CARMA_InitializeVertical</A> (carma, rc, vf_const)
    public subroutine <A HREF="carma_mod.html#subroutine_carma_destroy">CARMA_Destroy</A> (carma, rc)
    public subroutine <A HREF="carma_mod.html#subroutine_carma_addcoagulation">CARMA_AddCoagulation</A> (carma, igroup1, igroup2, igroup3, icollec, rc, ck0, grav_e_coll0, use_ccd)
    public subroutine <A HREF="carma_mod.html#subroutine_carma_addgrowth">CARMA_AddGrowth</A> (carma, ielem, igas, rc)
    public subroutine <A HREF="carma_mod.html#subroutine_carma_addnucleation">CARMA_AddNucleation</A> (carma, ielemfrom, ielemto, inucproc, rlh_nuc, rc, igas, ievp2elem)
    public subroutine <A HREF="carma_mod.html#subroutine_carma_get">CARMA_Get</A> (carma, rc, LUNOPRT, NBIN, NELEM, NGAS, NGROUP, NSOLUTE, NWAVE, NREFIDX, do_detrain, do_drydep, do_fixedinit, do_grow, do_print, do_print_init, do_thermo, wave, dwave, do_wave_emit, do_partialinit, do_coremasscheck, igash2o)

end module carma_mod
</PRE>
 The CARMA module contains an interface to the Community Aerosol and Radiation
 Model for Atmospheres (CARMA) bin microphysical model [Turco et al. 1979;
 Toon et al. 1988]. This implementation has been customized to work within
 other model frameworks, so although it can be provided with an array of
 columns, it does not do horizontal transport and just does independent 1-D
 calculations upon each column.
<P>
 The typical usage for the CARMA and CARMASTATE objects within a model would be:
<PRE> 
   ! This first section of code is done during the parent model's initialzation,
   ! and there should be a unique CARMA object created for each thread of
   ! execution.

   ! Create the CARMA object.
   call CARMA_Create(carma, ...)

   ! Define the microphysical components.
   call CARMAGROUP_Create(carma, ...)      ! One or more calls

   call CARMAELEMENT_Create(carma, ...)  ! One or more calls

   call CARMASOLUTE_Create(carma, ...)    ! Zero or more calls

   call CARMAGAS_Create(carma, ...)          ! Zero or more calls

   ! Define the relationships for the microphysical processes.
   call CARMA_AddCoagulation(carma, ...)    ! Zero or more calls
   call CARMA_AddGrowth(carma, ...)         ! Zero or more calls
   call CARMA_AddNucleation(carma, ...)     ! Zero or more calls

   ! Initialize things that are state and timestep independent.
   call CARMA_Initialize(carma, ...)

   ...

   ! This section of code is within the parent model's timing loop.
   !
   ! NOTE: If using OPEN/MP, then each thread will execute one of
   ! of these loops per column of data. To avoid having to destroy
   ! the CARMASTATE object, a pool of CARMASTATE objects could be
   ! created so that there is one per thread and then the
   ! CARMA_Destroy() could be called after all columns have been
   ! processed.

   ! Initialize CARMA for this model state and timestep.
   call CARMASTATE_Create(cstate, carma, ...)

   ! Set the model state for each bin and gas.
   call CARMASTATE_SetBin(cstate, ...)          ! One call for each bin
   call CARMASTATE_SetGas(cstate, ...)          ! One call for each gas

   ! Calculate the new state
   call CARMASTATE_Step(cstate, ...)

   ! Get the results to return back to the parent model.
   call CARMASTATE_GetBin(cstate, ...)      ! One call for each Bin
   call CARMASTATE_GetGas(cstate, ...)      ! One call for each gas
   call CARMASTATE_GetState(cstate, ...)    ! Zero or one calls

   ! (optional) Deallocate arrays that are not needed beyond this timestep.
   call CARMASTATE_Destroy(cstate)

   ...

   ! This section of code is done during the parent model's cleanup.

   ! Deallocate all arrays.
   call CARMA_Destroy(carma)
 </PRE>
<P>
<STRONG>Author:</STRONG> Chuck Bardeen, Pete Colarco, Jamie Smith
<P>
<STRONG>Version:</STRONG> Feb-2009

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_carma_create"><H3>CARMA_Create</H3></A>
<PRE>public subroutine CARMA_Create (carma, NBIN, NELEM, NGROUP, NSOLUTE, NGAS, NWAVE, rc, LUNOPRT, wave, dwave, do_wave_emit, NREFIDX)
    type (carma_type), intent(out) :: carma
</PRE>
<DL><DD><DL><DD>
 the carma object
</DL></DL>
<PRE>    integer, intent(in) :: NBIN
</PRE>
<DL><DD><DL><DD>
 number of radius bins per group
</DL></DL>
<PRE>    integer, intent(in) :: NELEM
</PRE>
<DL><DD><DL><DD>
 total number of elements
</DL></DL>
<PRE>    integer, intent(in) :: NGROUP
</PRE>
<DL><DD><DL><DD>
 total number of groups
</DL></DL>
<PRE>    integer, intent(in) :: NSOLUTE
</PRE>
<DL><DD><DL><DD>
 total number of solutes
</DL></DL>
<PRE>    integer, intent(in) :: NGAS
</PRE>
<DL><DD><DL><DD>
 total number of gases
</DL></DL>
<PRE>    integer, intent(in) :: NWAVE
</PRE>
<DL><DD><DL><DD>
 number of wavelengths
</DL></DL>
<PRE>    integer, intent(out) :: rc
</PRE>
<DL><DD><DL><DD>
 return code, negative indicates failure
</DL></DL>
<PRE>    integer, optional, intent(in) :: LUNOPRT
</PRE>
<DL><DD><DL><DD>
 logical unit number for output
</DL></DL>
<PRE>    real (kind=f), optional, intent(in), dimension (NWAVE) :: wave
</PRE>
<DL><DD><DL><DD>
 wavelength centers (cm)
</DL></DL>
<PRE>    real (kind=f), optional, intent(in), dimension (NWAVE) :: dwave
</PRE>
<DL><DD><DL><DD>
 wavelength width (cm)
</DL></DL>
<PRE>    logical, optional, intent(in), dimension (NWAVE) :: do_wave_emit
</PRE>
<DL><DD><DL><DD>
 do emission in band?
</DL></DL>
<PRE>    integer, optional, intent(in) :: NREFIDX
</PRE>
<DL><DD><DL><DD>
 number of refractive indices per wavelength
</DL></DL>
<PRE>end subroutine CARMA_Create
</PRE>
 Creates the CARMA object and allocates arrays to store configuration information
 that will follow from the CARMA_AddXXX() methods. When the CARMA object is no longer
 needed, the CARMA_Destroy() method should be used to clean up any allocations
 that have happened. If LUNOPRT is specified, then the logical unit should be open and
 ready for output. The caller is responsible for closing the LUNOPRT logical unit
 after the CARMA object has been destroyed.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> Feb-2009
<A NAME="subroutine_carma_initialize"><H3>CARMA_Initialize</H3></A>
<PRE>public subroutine CARMA_Initialize (carma, rc, do_cnst_rlh, do_coag, do_detrain, do_fixedinit, do_grow, do_incloud, do_explised, do_print_init, do_substep, do_thermo, do_vdiff, do_vtran, do_drydep, vf_const, minsubsteps, maxsubsteps, maxretries, conmax, do_pheat, do_pheatatm, dt_threshold, cstick, gsticki, gstickl, tstick, do_clearsky, do_partialinit, do_coremasscheck, sulfnucl_method)
    type (carma_type), intent(inout) :: carma
</PRE>
<DL><DD><DL><DD>
 the carma object
</DL></DL>
<PRE>    integer, intent(out) :: rc
</PRE>
<DL><DD><DL><DD>
 return code, negative indicates failure
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_cnst_rlh
</PRE>
<DL><DD><DL><DD>
 use constant values for latent heats
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_coag
</PRE>
<DL><DD><DL><DD>
 (instead of varying with temperature)?
 do coagulation?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_detrain
</PRE>
<DL><DD><DL><DD>
 do detrainement?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_fixedinit
</PRE>
<DL><DD><DL><DD>
 do initialization from reference atm?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_grow
</PRE>
<DL><DD><DL><DD>
 do nucleation, growth and evaporation?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_incloud
</PRE>
<DL><DD><DL><DD>
 do incloud growth and coagulation?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_explised
</PRE>
<DL><DD><DL><DD>
 do sedimentation with substepping
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_print_init
</PRE>
<DL><DD><DL><DD>
 do prinit initializtion information
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_substep
</PRE>
<DL><DD><DL><DD>
 do substepping
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_thermo
</PRE>
<DL><DD><DL><DD>
 do thermodynamics
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_vdiff
</PRE>
<DL><DD><DL><DD>
 do Brownian diffusion
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_vtran
</PRE>
<DL><DD><DL><DD>
 do sedimentation
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_drydep
</PRE>
<DL><DD><DL><DD>
 do dry deposition
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: vf_const
</PRE>
<DL><DD><DL><DD>
 if specified and non-zero,
</DL></DL>
<PRE>    integer, optional, intent(in) :: minsubsteps
</PRE>
<DL><DD><DL><DD>
 constant fall velocity for all particles [cm/s]
 minimum number of substeps, default = 1
</DL></DL>
<PRE>    integer, optional, intent(in) :: maxsubsteps
</PRE>
<DL><DD><DL><DD>
 maximum number of substeps, default = 1
</DL></DL>
<PRE>    integer, optional, intent(in) :: maxretries
</PRE>
<DL><DD><DL><DD>
 maximum number of substep retries, default = 5
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: conmax
</PRE>
<DL><DD><DL><DD>
 minimum relative concentration to consider, default = 1e-1
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_pheat
</PRE>
<DL><DD><DL><DD>
 do particle heating
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_pheatatm
</PRE>
<DL><DD><DL><DD>
 do particle heating of atmosphere
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: dt_threshold
</PRE>
<DL><DD><DL><DD>
 convergence criteria for temperature [fraction]
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: cstick
</PRE>
<DL><DD><DL><DD>
 accommodation coefficient - coagulation, default = 1.0
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: gsticki
</PRE>
<DL><DD><DL><DD>
 accommodation coefficient - growth (ice), default = 0.93
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: gstickl
</PRE>
<DL><DD><DL><DD>
 accommodation coefficient - growth (liquid), default = 1.0
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: tstick
</PRE>
<DL><DD><DL><DD>
 accommodation coefficient - temperature, default = 1.0
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_clearsky
</PRE>
<DL><DD><DL><DD>
 do clear sky growth and coagulation?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_partialinit
</PRE>
<DL><DD><DL><DD>
 do initialization of coagulation from reference atm (requires do_fixedinit)?
</DL></DL>
<PRE>    logical, optional, intent(in) :: do_coremasscheck
    character (len=*), optional, intent(in) :: sulfnucl_method
    ! Calls: <A HREF="CARMA_InitializeGrowth.html">CARMA_InitializeGrowth</A>, <A HREF="CARMA_InitializeOptics.html">CARMA_InitializeOptics</A>, <A HREF="CARMA_InitializeThermo.html">CARMA_InitializeThermo</A>, <A HREF="CARMA_InitializeVertical.html">CARMA_InitializeVertical</A>, <A HREF="setupbins.html">setupbins</A>, <A HREF="setupcoag.html">setupcoag</A>
end subroutine CARMA_Initialize
</PRE>
 Called after the CARMA object has been created and the microphysics description has been
 configured. The optional flags control which microphysical processes are enabled and all of
 them default to FALSE. For a microphysical process to be active it must have been both
 configured (using a CARMA_AddXXX() method) and enabled here.
<P>
 NOTE: After initialization, the structure of the particle size bins is determined, and
 the resulting r, dr, rmass and dm can be retrieved with the CARMA_GetGroup() method.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> Feb-2009
<A NAME="subroutine_carma_initializegrowth"><H3>CARMA_InitializeGrowth</H3></A>
<PRE>private subroutine CARMA_InitializeGrowth (carma, rc)
    type (carma_type), intent(inout) :: carma
    integer, intent(out) :: rc
end subroutine CARMA_InitializeGrowth
</PRE>
<A NAME="subroutine_carma_initializeoptics"><H3>CARMA_InitializeOptics</H3></A>
<PRE>private subroutine CARMA_InitializeOptics (carma, rc)
    type (carma_type), intent(inout) :: carma
    integer, intent(out) :: rc
    ! Calls: <A HREF="mie.html">mie</A>
end subroutine CARMA_InitializeOptics
</PRE>
 Calculate the optical properties for each particle bin at each of
 the specified wavelengths. The optical properties include the
 extinction efficiency, the single scattering albedo and the
 asymmetry factor.
<P>
 NOTE: For these calculations, the particles are assumed to be spheres and
 Mie code is used to calculate the optical properties.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> May-2009
<A NAME="subroutine_carma_initializethermo"><H3>CARMA_InitializeThermo</H3></A>
<PRE>private subroutine CARMA_InitializeThermo (carma, rc)
    type (carma_type), intent(inout) :: carma
    integer, intent(out) :: rc
end subroutine CARMA_InitializeThermo
</PRE>
 Perform initialization of variables related to thermodynamical calculations that
 are not dependent on the model state.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> May-2009
<A NAME="subroutine_carma_initializevertical"><H3>CARMA_InitializeVertical</H3></A>
<PRE>private subroutine CARMA_InitializeVertical (carma, rc, vf_const)
    type (carma_type), intent(inout) :: carma
    integer, intent(out) :: rc
    real (kind=f), optional, intent(in) :: vf_const
end subroutine CARMA_InitializeVertical
</PRE>
 Perform initialization of variables related to vertical transport that are not dependent
 on the model state.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> May-2009
<A NAME="subroutine_carma_destroy"><H3>CARMA_Destroy</H3></A>
<PRE>public subroutine CARMA_Destroy (carma, rc)
    type (carma_type), intent(inout) :: carma
    integer, intent(out) :: rc
    ! Calls: <A HREF="CARMAELEMENT_Destroy.html">CARMAELEMENT_Destroy</A>, <A HREF="CARMAGAS_Destroy.html">CARMAGAS_Destroy</A>, <A HREF="CARMAGROUP_Destroy.html">CARMAGROUP_Destroy</A>, <A HREF="CARMASOLUTE_Destroy.html">CARMASOLUTE_Destroy</A>
end subroutine CARMA_Destroy
</PRE>
 The routine should be called when the carma object is no longer needed. It deallocates
 any memory allocations made by CARMA (during CARMA_Create()), and failure to call this
routine could result in memory leaks.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> May-2009
<P>
<STRONG>See also:</STRONG> module <A HREF="CARMA_Create.html">CARMA_Create</A>
<A NAME="subroutine_carma_addcoagulation"><H3>CARMA_AddCoagulation</H3></A>
<PRE>public subroutine CARMA_AddCoagulation (carma, igroup1, igroup2, igroup3, icollec, rc, ck0, grav_e_coll0, use_ccd)
    type (carma_type), intent(inout) :: carma
</PRE>
<DL><DD><DL><DD>
 the carma object
</DL></DL>
<PRE>    integer, intent(in) :: igroup1
</PRE>
<DL><DD><DL><DD>
 first source group
</DL></DL>
<PRE>    integer, intent(in) :: igroup2
</PRE>
<DL><DD><DL><DD>
 second source group
</DL></DL>
<PRE>    integer, intent(in) :: igroup3
</PRE>
<DL><DD><DL><DD>
 destination group
</DL></DL>
<PRE>    integer, intent(in) :: icollec
</PRE>
<DL><DD><DL><DD>
 collection technique [I_COLLEC_CONST | I_COLLEC_FUCHS | I_COLLEC_DATA]
</DL></DL>
<PRE>    integer, intent(out) :: rc
</PRE>
<DL><DD><DL><DD>
 return code, negative indicates failure
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: ck0
</PRE>
<DL><DD><DL><DD>
 if specified, forces a constant coagulation kernel
</DL></DL>
<PRE>    real (kind=f), optional, intent(in) :: grav_e_coll0
</PRE>
<DL><DD><DL><DD>
 if <i>icollec</i> is I_COLLEC_CONST
</DL></DL>
<PRE>    logical, optional, intent(in) :: use_ccd
</PRE>
<DL><DD><DL><DD>
 the constant gravitational collection efficiency
 if ccd is turned on
</DL></DL>
<PRE>end subroutine CARMA_AddCoagulation
</PRE>
 Add a coagulation process between two groups (<i>igroup1</i> and <i>igroup2</i>), with the resulting
 particle being in the destination group (<i>igroup3</i>). If <i>ck0</i> is specifed, then a constant
 coagulation kernel will be used.
<A NAME="subroutine_carma_addgrowth"><H3>CARMA_AddGrowth</H3></A>
<PRE>public subroutine CARMA_AddGrowth (carma, ielem, igas, rc)
    type (carma_type), intent(inout) :: carma
</PRE>
<DL><DD><DL><DD>
 the carma object
</DL></DL>
<PRE>    integer, intent(in) :: ielem
</PRE>
<DL><DD><DL><DD>
 the element index
</DL></DL>
<PRE>    integer, intent(in) :: igas
</PRE>
<DL><DD><DL><DD>
 the gas index
</DL></DL>
<PRE>    integer, intent(out) :: rc
</PRE>
<DL><DD><DL><DD>
 return code, negative indicates failure
</DL></DL>
<PRE>end subroutine CARMA_AddGrowth
</PRE>
 Add a growth process between the element (<i>ielem</i>) and gas (<i>igas</i>) specifed. The element
 and gas should have already been defined using <i>CARMA_AddElement()</i> and <i>CARMA_AddGas()</i>.
<P>
 NOTE: Each element can only have one volatile component.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> May-2009
<P>
<STRONG>See also:</STRONG> module <A HREF="CARMA_AddElement.html">CARMA_AddElement</A>, module <A HREF="CARMA_AddGas.html">CARMA_AddGas</A>
<A NAME="subroutine_carma_addnucleation"><H3>CARMA_AddNucleation</H3></A>
<PRE>public subroutine CARMA_AddNucleation (carma, ielemfrom, ielemto, inucproc, rlh_nuc, rc, igas, ievp2elem)
    type (carma_type), intent(inout) :: carma
</PRE>
<DL><DD><DL><DD>
 the carma object
</DL></DL>
<PRE>    integer, intent(in) :: ielemfrom
</PRE>
<DL><DD><DL><DD>
 the source element
</DL></DL>
<PRE>    integer, intent(in) :: ielemto
</PRE>
<DL><DD><DL><DD>
 the destination element
</DL></DL>
<PRE>    integer, intent(in) :: inucproc
</PRE>
<DL><DD><DL><DD>
 the nucleation process
</DL></DL>
<PRE>    real (kind=f), intent(in) :: rlh_nuc
</PRE>
<DL><DD><DL><DD>
 [I_DROPACT | I_AERFREEZE | I_ICEMELT | I_HETNUC | I_HOMNUC]
 the latent heat of nucleation [cm<sup>2</sup>/s<sup>2</sup>]
</DL></DL>
<PRE>    integer, intent(out) :: rc
</PRE>
<DL><DD><DL><DD>
 return code, negative indicated failure
</DL></DL>
<PRE>    integer, optional, intent(in) :: igas
</PRE>
<DL><DD><DL><DD>
 the gas
</DL></DL>
<PRE>    integer, optional, intent(in) :: ievp2elem
</PRE>
<DL><DD><DL><DD>
 the element created upon evaporation
</DL></DL>
<PRE>    ! Calls: <A HREF="CARMAELEMENT_Get.html">CARMAELEMENT_Get</A>
end subroutine CARMA_AddNucleation
</PRE>
 Add a nucleation process that nucleates one element (<i>elemfrom</i>) to another element (<i>elemto</i>)
 using the specified gas (<i>igas</i>). The elements and gas should have already been defined
 using <i>CARMA_AddElement()</i> and <i>CARMA_AddGas()</i>. The nucleation scheme is indicated by
 inucproc, and can be one of:
<P>
   <UL>
   <LI>  <i>I_DROPACT</i>
   <LI>  <i>I_AERFREEZE</i>
   <LI>  <i>I_DROPFREEZE</i>
   <LI>  <i>I_ICEMELT</i>
   <LI>  <i>I_HETNUC</i>
   <LI>  <i>I_HOMNUC</i>
<P>
   </UL>
 There are multiple parameterizations for I_AERFREEZE, so when that is selected the
 particular parameterization needs to be indicated by adding it to I_AERFREEZE. The
 specific routines are:
<P>
   <UL>
   <LI>  <i>I_AF_TABAZADEH_2000</i>
   <LI>  <i>I_AF_KOOP_2000</i>
   <LI>  <i>I_AF_MOHLER_2010</i>
   <LI>  <i>I_AF_MURRAY_2010</i>
<P>
   </UL>
 One or more of these routines may be selected, but in general one of the first
 three should be selected and then it can optionally be combined with the glassy
 aerosols (I_AF_MURRAY_2010).
<P>
 Total evaporation transfers particle mass from the destination element back to the
 element indicated by <i>ievp2elem</i>. This relationship is not automatically generated,
 because multiple elements can nucleate to a particular element and therefore the
 reverse mapping is not unique.
<P>
 NOTE: The gas used for nucleation must be the same for all nucleation defined from
 elements of the same group.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> Feb-2009
<P>
<STRONG>See also:</STRONG> module <A HREF="I_DROPACT.html">I_DROPACT</A>, module <A HREF="I_AERFREEZE.html">I_AERFREEZE</A>, module <A HREF="I_DROPFREEZE.html">I_DROPFREEZE</A>, module <A HREF="I_ICEMELT.html">I_ICEMELT</A>, module <A HREF="I_HETNUC.html">I_HETNUC</A>, module <A HREF="I_HOMNUC.html">I_HOMNUC</A>, module <A HREF="I_AF_TABAZADEH_2000.html">I_AF_TABAZADEH_2000</A>, module <A HREF="I_AF_KOOP_2000.html">I_AF_KOOP_2000</A>, module <A HREF="I_AF_MOHLER_2010.html">I_AF_MOHLER_2010</A>, module <A HREF="I_AF_MURRAY_2010.html">I_AF_MURRAY_2010</A>, module <A HREF="CARMA_AddElement.html">CARMA_AddElement</A>, module <A HREF="CARMA_AddGas.html">CARMA_AddGas</A>
<A NAME="subroutine_carma_get"><H3>CARMA_Get</H3></A>
<PRE>public subroutine CARMA_Get (carma, rc, LUNOPRT, NBIN, NELEM, NGAS, NGROUP, NSOLUTE, NWAVE, NREFIDX, do_detrain, do_drydep, do_fixedinit, do_grow, do_print, do_print_init, do_thermo, wave, dwave, do_wave_emit, do_partialinit, do_coremasscheck, igash2o)
    type (carma_type), intent(in) :: carma
</PRE>
<DL><DD><DL><DD>
 the carma object
</DL></DL>
<PRE>    integer, intent(out) :: rc
</PRE>
<DL><DD><DL><DD>
 return code, negative indicates failure
</DL></DL>
<PRE>    integer, optional, intent(out) :: LUNOPRT
</PRE>
<DL><DD><DL><DD>
 logical unit number for output
</DL></DL>
<PRE>    integer, optional, intent(out) :: NBIN
</PRE>
<DL><DD><DL><DD>
 number of radius bins per group
</DL></DL>
<PRE>    integer, optional, intent(out) :: NELEM
</PRE>
<DL><DD><DL><DD>
 total number of elements
</DL></DL>
<PRE>    integer, optional, intent(out) :: NGAS
</PRE>
<DL><DD><DL><DD>
 total number of gases
</DL></DL>
<PRE>    integer, optional, intent(out) :: NGROUP
</PRE>
<DL><DD><DL><DD>
 total number of groups
</DL></DL>
<PRE>    integer, optional, intent(out) :: NSOLUTE
</PRE>
<DL><DD><DL><DD>
 total number of solutes
</DL></DL>
<PRE>    integer, optional, intent(out) :: NWAVE
</PRE>
<DL><DD><DL><DD>
 number of wavelengths
</DL></DL>
<PRE>    integer, optional, intent(out) :: NREFIDX
</PRE>
<DL><DD><DL><DD>
 number of refractive indices per element
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_detrain
</PRE>
<DL><DD><DL><DD>
 do detrainement?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_drydep
</PRE>
<DL><DD><DL><DD>
 do dry deposition?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_fixedinit
</PRE>
<DL><DD><DL><DD>
 do initialization from reference atm?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_grow
</PRE>
<DL><DD><DL><DD>
 do condensational growth?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_print
</PRE>
<DL><DD><DL><DD>
 do print output?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_print_init
</PRE>
<DL><DD><DL><DD>
 do print initialization output?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_thermo
</PRE>
<DL><DD><DL><DD>
 do thermodynamics?
</DL></DL>
<PRE>    real (kind=f), optional, intent(out), dimension (carma%f_NWAVE) :: wave
</PRE>
<DL><DD><DL><DD>
 the wavelengths centers (cm)
</DL></DL>
<PRE>    real (kind=f), optional, intent(out), dimension (carma%f_NWAVE) :: dwave
</PRE>
<DL><DD><DL><DD>
 the wavelengths widths (cm)
</DL></DL>
<PRE>    logical, optional, intent(out), dimension (carma%f_NWAVE) :: do_wave_emit
</PRE>
<DL><DD><DL><DD>
 do emission in this band?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_partialinit
</PRE>
<DL><DD><DL><DD>
 do initialization of coagulation from reference atm?
</DL></DL>
<PRE>    logical, optional, intent(out) :: do_coremasscheck
    integer, optional, intent(out) :: igash2o
</PRE>
<DL><DD><DL><DD>
 Gas index for H2O.
</DL></DL>
<PRE>end subroutine CARMA_Get
</PRE>
 Gets the information about the carma object.
<P>
<STRONG>Author:</STRONG> Chuck Bardeen
<P>
<STRONG>Version:</STRONG> May-2009
<P>
<STRONG>See also:</STRONG> module <A HREF="CARMA_Create.html">CARMA_Create</A>
</HTML>
