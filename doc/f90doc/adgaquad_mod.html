<HTML>
<HEAD>
   <TITLE> module adgaquad_mod (generated by f90doc) </TITLE>
</HEAD>
<H1> Module adgaquad_mod </H1>
<PRE>module adgaquad_mod

        ! Uses
    use <A HREF="carma_precision_mod.html">carma_precision_mod</A>
    use <A HREF="adgaquad_types_mod.html">adgaquad_types_mod</A>

        ! Subroutines and functions
    public subroutine <A HREF="adgaquad_mod.html#subroutine_dqag">dqag</A> (fx, fx_vars, a, b, epsabs, epsrel, key, result, abserr, neval, ier, limit, lenw, last, iwork, work)
    public subroutine <A HREF="adgaquad_mod.html#subroutine_dqage">dqage</A> (fx, fx_vars, a, b, epsabs, epsrel, key, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)
    public subroutine <A HREF="adgaquad_mod.html#subroutine_dqagi">dqagi</A> (fx, fx_vars, bound, inf, epsabs, epsrel, result, abserr, neval, ier, limit, lenw, last, iwork, work)
    public subroutine <A HREF="adgaquad_mod.html#subroutine_dqagie">dqagie</A> (fx, fx_vars, bound, inf, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk15">dqk15</A> (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk21">dqk21</A> (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk31">dqk31</A> (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk41">dqk41</A> (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk51">dqk51</A> (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk61">dqk61</A> (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqpsrt">dqpsrt</A> (limit, last, maxerr, ermax, elist, iord, nrmax)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqk15i">dqk15i</A> (fx, fx_vars, boun, inf, a, b, result, abserr, resabs, resasc, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_dqelg">dqelg</A> (n, epstab, result, abserr, res3la, nres, ier)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_sd1mach">SD1MACH</A> (I, D1MACH_OUT, IER)
    private subroutine <A HREF="adgaquad_mod.html#subroutine_i1mcry">I1MCRY</A> (A, A1, B, C, D)

end module adgaquad_mod
</PRE>
 ******************************************************************
 The routines listed in this file "adgaquad_mod.F90" are performing
 Numerical Integrations using some kind of 
 adaptive Gauss quadrature.
 They are taken from the Internet (http://www.netlib.org)
 and parts of different software packages / libraries.
 ******************************************************************
 For any restrictions on the use of the routines, please see
 the original web site. 
 ******************************************************************
 Changes: calls to error handler 'xerror()' replaced by
          WRITE(7,*) - statements.
 ******************************************************************
 list of routines and the libraries they are taken from:
  dqag		calling routine, bounded integration interval
			QUADPACK; calls: dqage
  dqage		the integration routine, bounded interval
			QUADPACK; calls: sd1mach,dqk15,dqk21,dqk31,
					dqk41,dqk51,dqk61,dqpsrt
  dqagi		calling routine, unbounded (semi-infinite or 
			infinite) integration interval
			QUADPACK; calls: dqagie
  dqagie		the integration routine, unbounded interval
			QUADPACK; calls: sd1mach,dqelg,dqk15i,dqpsrt
 <UL>
 <LI> -----------------------------------------------------------------
  dqk15		QUADPACK; calls: sd1mach
  dqk21		QUADPACK; calls: sd1mach
  dqk31		QUADPACK; calls: sd1mach
  dqk41		QUADPACK; calls: sd1mach
  dqk51		QUADPACK; calls: sd1mach
  dqk61		QUADPACK; calls: sd1mach
  dqpsrt		QUADPACK; calls: none
  dqk15i		QUADPACK; calls: sd1mach
  dqelg		QUADPACK; calls: sd1mach
 <LI> -----------------------------------------------------------------
  xerror		Error handling routine
 </UL>
			ALLIANT (/quad); calls: xerrwv
  xerrwv		Error handling routine
			SODEPACK; calls: none
  d1mach		determine machine parameters (accuracies)
			BLAS; calls: none
 <UL>
 <LI> -----------------------------------------------------------------
 </UL>

<HR><H2> Description of Subroutines and Functions </H2>
<A NAME="subroutine_dqag"><H3>dqag</H3></A>
<PRE>public subroutine dqag (fx, fx_vars, a, b, epsabs, epsrel, key, result, abserr, neval, ier, limit, lenw, last, iwork, work)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: epsabs
    real (kind=f) :: epsrel
    integer :: key
    real (kind=f) :: result
    real (kind=f) :: abserr
    integer :: neval
    integer :: ier
    integer :: limit
    integer :: lenw
    integer :: last
    integer, dimension (limit) :: iwork
    real (kind=f), dimension (lenw) :: work
    ! Calls: <A HREF="dqage.html">dqage</A>
end subroutine dqag
</PRE>
***begin prologue  dqag
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)  
***category no.  h2a1a1
***keywords  automatic integrator, general-purpose,
             integrand examinator, globally adaptive,
             gauss-kronrod
***author  piessens,robert,appl. math. & progr. div - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  the routine calculates an approximation result to a given
            definite integral i = integral of f over (a,b),
            hopefully satisfying following claim for accuracy
            abs(i-result)le.max(epsabs,epsrel*abs(i)).
***description
<P>
        computation of a definite integral
        standard fortran subroutine
        double precision version
<P>
            fx     - double precision
                     function subprogam defining the integrand
                     function f(x). the actual name for f needs to be
                     declared e x t e r n a l in the driver program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
<P>
            a      - double precision
                     lower limit of integration
<P>
            b      - double precision
                     upper limit of integration
<P>
            epsabs - double precision
                     absolute accoracy requested
            epsrel - double precision
                     relative accuracy requested
                     if  epsabs.le.0
                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
                     the routine will end with ier = 6.
<P>
            key    - integer
                     key for choice of local integration rule
                     a gauss-kronrod pair is used with
                       7 - 15 points if key.lt.2,
                      10 - 21 points if key = 2,
                      15 - 31 points if key = 3,
                      20 - 41 points if key = 4,
                      25 - 51 points if key = 5,
                      30 - 61 points if key.gt.5.
<P>
         on return
            result - double precision
                     approximation to the integral
<P>
            abserr - double precision
                     estimate of the modulus of the absolute error,
                     which should equal or exceed abs(i-result)
<P>
            neval  - integer
                     number of integrand evaluations
<P>
            ier    - integer
                     ier = 0 normal and reliable termination of the
                             routine. it is assumed that the requested
                             accuracy has been achieved.
                     ier.gt.0 abnormal termination of the routine
                             the estimates for result and error are
                             less reliable. it is assumed that the
                             requested accuracy has not been achieved.
                      error messages
                     ier = 1 maximum number of subdivisions allowed
                             has been achieved. one can allow more
                             subdivisions by increasing the value of
                             limit (and taking the according dimension
                             adjustments into account). however, if
                             this yield no improvement it is advised
                             to analyze the integrand in order to
                             determine the integration difficulaties.
                             if the position of a local difficulty can
                             be determined (i.e.singularity,
                             discontinuity within the interval) one
                             will probably gain from splitting up the
                             interval at this point and calling the
                             integrator on the subranges. if possible,
                             an appropriate special-purpose integrator
                             should be used which is designed for
                             handling the type of difficulty involved.
                         = 2 the occurrence of roundoff error is
                             detected, which prevents the requested
                             tolerance from being achieved.
                         = 3 extremely bad integrand behaviour occurs
                             at some points of the integration
                             interval.
                         = 6 the input is invalid, because
                             (epsabs.le.0 and
                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
                             or limit.lt.1 or lenw.lt.limit*4.
                             result, abserr, neval, last are set
                             to zero.
                             except when lenw is invalid, iwork(1),
                             work(limit*2+1) and work(limit*3+1) are
                             set to zero, work(1) is set to a and
                             work(limit+1) to b.
		             = 9 failure in sd1mach determining machine parameters
<P>
         dimensioning parameters
            limit - integer
                    dimensioning parameter for iwork
                    limit determines the maximum number of subintervals
                    in the partition of the given integration interval
                    (a,b), limit.ge.1.
                    if limit.lt.1, the routine will end with ier = 6.
<P>
            lenw  - integer
                    dimensioning parameter for work
                    lenw must be at least limit*4.
                    if lenw.lt.limit*4, the routine will end with
                    ier = 6.
<P>
            last  - integer
                    on return, last equals the number of subintervals
                    produced in the subdiviosion process, which
                    determines the number of significant elements
                    actually in the work arrays.
<P>
         work arrays
            iwork - integer
                    vector of dimension at least limit, the first k
                    elements of which contain pointers to the error
                    estimates over the subintervals, such that
                    work(limit*3+iwork(1)),... , work(limit*3+iwork(k))
                    form a decreasing sequence with k = last if
                    last.le.(limit/2+2), and k = limit+1-last otherwise
<P>
            work  - double precision
                    vector of dimension at least lenw
                    on return
                    work(1), ..., work(last) contain the left end
                    points of the subintervals in the partition of
                     (a,b),
                    work(limit+1), ..., work(limit+last) contain the
                     right end points,
                    work(limit*2+1), ..., work(limit*2+last) contain
                     the integral approximations over the subintervals,
                    work(limit*3+1), ..., work(limit*3+last) contain
                     the error estimates.
<P>
***references  (none)
***routines called  dqage,xerror
***end prologue  dqag
<A NAME="subroutine_dqage"><H3>dqage</H3></A>
<PRE>public subroutine dqage (fx, fx_vars, a, b, epsabs, epsrel, key, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: epsabs
    real (kind=f) :: epsrel
    integer :: key
    integer :: limit
    real (kind=f) :: result
    real (kind=f) :: abserr
    integer :: neval
    integer :: ier
    real (kind=f), dimension (limit) :: alist
    real (kind=f), dimension (limit) :: blist
    real (kind=f), dimension (limit) :: rlist
    real (kind=f), dimension (limit) :: elist
    integer, dimension (limit) :: iord
    integer :: last
    ! Calls: <A HREF="dqk15.html">dqk15</A>, <A HREF="dqk21.html">dqk21</A>, <A HREF="dqk31.html">dqk31</A>, <A HREF="dqk41.html">dqk41</A>, <A HREF="dqk51.html">dqk51</A>, <A HREF="dqk61.html">dqk61</A>, <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqage
</PRE>
***begin prologue  dqage
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a1a1
***keywords  automatic integrator, general-purpose,
             integrand examinator, globally adaptive,
             gauss-kronrod
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  the routine calculates an approximation result to a given
            definite integral   i = integral of f over (a,b),
            hopefully satisfying following claim for accuracy
            abs(i-reslt).le.max(epsabs,epsrel*abs(i)).
***description
<P>
        computation of a definite integral
        standard fortran subroutine
        double precision version
<P>
        parameters
         on entry
            fx     - double precision
                     function subprogram defining the integrand
                     function f(x). the actual name for f needs to be
                     declared e x t e r n a l in the driver program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
<P>
            a      - double precision
                     lower limit of integration
<P>
            b      - double precision
                     upper limit of integration
<P>
            epsabs - double precision
                     absolute accuracy requested
            epsrel - double precision
                     relative accuracy requested
                     if  epsabs.le.0
                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
                     the routine will end with ier = 6.
<P>
            key    - integer
                     key for choice of local integration rule
                     a gauss-kronrod pair is used with
                          7 - 15 points if key.lt.2,
                         10 - 21 points if key = 2,
                         15 - 31 points if key = 3,
                         20 - 41 points if key = 4,
                         25 - 51 points if key = 5,
                         30 - 61 points if key.gt.5.
<P>
            limit  - integer
                     gives an upperbound on the number of subintervals
                     in the partition of (a,b), limit.ge.1.
<P>
         on return
            result - double precision
                     approximation to the integral
<P>
            abserr - double precision
                     estimate of the modulus of the absolute error,
                     which should equal or exceed abs(i-result)
<P>
            neval  - integer
                     number of integrand evaluations
<P>
            ier    - integer
                     ier = 0 normal and reliable termination of the
                             routine. it is assumed that the requested
                             accuracy has been achieved.
                     ier.gt.0 abnormal termination of the routine
                             the estimates for result and error are
                             less reliable. it is assumed that the
                             requested accuracy has not been achieved.
            error messages
                     ier = 1 maximum number of subdivisions allowed
                             has been achieved. one can allow more
                             subdivisions by increasing the value
                             of limit.
                             however, if this yields no improvement it
                             is rather advised to analyze the integrand
                             in order to determine the integration
                             difficulties. if the position of a local
                             difficulty can be determined(e.g.
                             singularity, discontinuity within the
                             interval) one will probably gain from
                             splitting up the interval at this point
                             and calling the integrator on the
                             subranges. if possible, an appropriate
                             special-purpose integrator should be used
                             which is designed for handling the type of
                             difficulty involved.
                         = 2 the occurrence of roundoff error is
                             detected, which prevents the requested
                             tolerance from being achieved.
                         = 3 extremely bad integrand behaviour occurs
                             at some points of the integration
                             interval.
                         = 6 the input is invalid, because
                             (epsabs.le.0 and
                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
                             result, abserr, neval, last, rlist(1) ,
                             elist(1) and iord(1) are set to zero.
                             alist(1) and blist(1) are set to a and b
                             respectively.
                         = 9 failure in sd1mach determining machine parameters
<P>
            alist   - double precision
                      vector of dimension at least limit, the first
                       last  elements of which are the left
                      end points of the subintervals in the partition
                      of the given integration range (a,b)
<P>
            blist   - double precision
                      vector of dimension at least limit, the first
                       last  elements of which are the right
                      end points of the subintervals in the partition
                      of the given integration range (a,b)
<P>
            rlist   - double precision
                      vector of dimension at least limit, the first
                       last  elements of which are the
                      integral approximations on the subintervals
<P>
            elist   - double precision
                      vector of dimension at least limit, the first
                       last  elements of which are the moduli of the
                       absolute error estimates on the subintervals
<P>
            iord    - integer
                      vector of dimension at least limit, the first k
                      elements of which are pointers to the
                      error estimates over the subintervals,
                      such that elist(iord(1)), ...,
                      elist(iord(k)) form a decreasing sequence,
                      with k = last if last.le.(limit/2+2), and
                      k = limit+1-last otherwise
<P>
            last    - integer
                      number of subintervals actually produced in the
                      subdivision process
<P>
***references  (none)
***routines called  sd1mach,dqk15,dqk21,dqk31,
                    dqk41,dqk51,dqk61,dqpsrt
***end prologue  dqage
<A NAME="subroutine_dqagi"><H3>dqagi</H3></A>
<PRE>public subroutine dqagi (fx, fx_vars, bound, inf, epsabs, epsrel, result, abserr, neval, ier, limit, lenw, last, iwork, work)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: bound
    integer :: inf
    real (kind=f) :: epsabs
    real (kind=f) :: epsrel
    real (kind=f) :: result
    real (kind=f) :: abserr
    integer :: neval
    integer :: ier
    integer :: limit
    integer :: lenw
    integer :: last
    integer, dimension (limit) :: iwork
    real (kind=f), dimension (lenw) :: work
    ! Calls: <A HREF="dqagie.html">dqagie</A>
end subroutine dqagi
</PRE>
***begin prologue  dqagi
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a3a1,h2a4a1
***keywords  automatic integrator, infinite intervals,
             general-purpose, transformation, extrapolation,
             globally adaptive
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. -k.u.leuven
***purpose  the routine calculates an approximation result to a given
            integral   i = integral of f over (bound,+infinity)
            or i = integral of f over (-infinity,bound)
            or i = integral of f over (-infinity,+infinity)
            hopefully satisfying following claim for accuracy
            abs(i-result).le.max(epsabs,epsrel*abs(i)).
***description
<P>
        integration over infinite intervals
        standard fortran subroutine
<P>
        parameters
         on entry
            fx     - double precision
                     function subprogram defining the integrand
                     function f(x). the actual name for f needs to be
                     declared e x t e r n a l in the driver program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
<P>
            bound  - double precision
                     finite bound of integration range
                     (has no meaning if interval is doubly-infinite)
<P>
            inf    - integer
                     indicating the kind of integration range involved
                     inf = 1 corresponds to  (bound,+infinity),
                     inf = -1            to  (-infinity,bound),
                     inf = 2             to (-infinity,+infinity).
<P>
            epsabs - double precision
                     absolute accuracy requested
            epsrel - double precision
                     relative accuracy requested
                     if  epsabs.le.0
                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
                     the routine will end with ier = 6.
<P>
         on return
            result - double precision
                     approximation to the integral
<P>
            abserr - double precision
                     estimate of the modulus of the absolute error,
                     which should equal or exceed abs(i-result)
<P>
            neval  - integer
                     number of integrand evaluations
<P>
            ier    - integer
                     ier = 0 normal and reliable termination of the
                             routine. it is assumed that the requested
                             accuracy has been achieved.
                   <UL>
                   <LI>  ier.gt.0 abnormal termination of the routine. the
                             estimates for result and error are less
                             reliable. it is assumed that the requested
                             accuracy has not been achieved.
                   </UL>
            error messages
                     ier = 1 maximum number of subdivisions allowed
                             has been achieved. one can allow more
                             subdivisions by increasing the value of
                             limit (and taking the according dimension
                             adjustments into account). however, if
                             this yields no improvement it is advised
                             to analyze the integrand in order to
                             determine the integration difficulties. if
                             the position of a local difficulty can be
                             determined (e.g. singularity,
                             discontinuity within the interval) one
                             will probably gain from splitting up the
                             interval at this point and calling the
                             integrator on the subranges. if possible,
                             an appropriate special-purpose integrator
                             should be used, which is designed for
                             handling the type of difficulty involved.
                         = 2 the occurrence of roundoff error is
                             detected, which prevents the requested
                             tolerance from being achieved.
                             the error may be under-estimated.
                         = 3 extremely bad integrand behaviour occurs
                             at some points of the integration
                             interval.
                         = 4 the algorithm does not converge.
                             roundoff error is detected in the
                             extrapolation table.
                             it is assumed that the requested tolerance
                             cannot be achieved, and that the returned
                             result is the best which can be obtained.
                         = 5 the integral is probably divergent, or
                             slowly convergent. it must be noted that
                             divergence can occur with any other value
                             of ier.
                         = 6 the input is invalid, because
                             (epsabs.le.0 and
                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28))
                              or limit.lt.1 or leniw.lt.limit*4.
                             result, abserr, neval, last are set to
                             zero. exept when limit or leniw is
                             invalid, iwork(1), work(limit*2+1) and
                             work(limit*3+1) are set to zero, work(1)
                             is set to a and work(limit+1) to b.
		             = 9 failure in sd1mach determining machine parameters
<P>
          dimensioning parameters
            limit - integer
                    dimensioning parameter for iwork
                    limit determines the maximum number of subintervals
                    in the partition of the given integration interval
                    (a,b), limit.ge.1.
                    if limit.lt.1, the routine will end with ier = 6.
<P>
            lenw  - integer
                    dimensioning parameter for work
                    lenw must be at least limit*4.
                    if lenw.lt.limit*4, the routine will end
                    with ier = 6.
<P>
            last  - integer
                    on return, last equals the number of subintervals
                    produced in the subdivision process, which
                    determines the number of significant elements
                    actually in the work arrays.
<P>
         work arrays
            iwork - integer
                    vector of dimension at least limit, the first
                    k elements of which contain pointers
                    to the error estimates over the subintervals,
                    such that work(limit*3+iwork(1)),... ,
                    work(limit*3+iwork(k)) form a decreasing
                    sequence, with k = last if last.le.(limit/2+2), and
                    k = limit+1-last otherwise
<P>
            work  - double precision
                    vector of dimension at least lenw
                    on return
                    work(1), ..., work(last) contain the left
                     end points of the subintervals in the
                     partition of (a,b),
                    work(limit+1), ..., work(limit+last) contain
                     the right end points,
                    work(limit*2+1), ...,work(limit*2+last) contain the
                     integral approximations over the subintervals,
                    work(limit*3+1), ..., work(limit*3)
                     contain the error estimates.
***references  (none)
***routines called  dqagie,xerror
***end prologue  dqagi
<A NAME="subroutine_dqagie"><H3>dqagie</H3></A>
<PRE>public subroutine dqagie (fx, fx_vars, bound, inf, epsabs, epsrel, limit, result, abserr, neval, ier, alist, blist, rlist, elist, iord, last)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: bound
    integer :: inf
    real (kind=f) :: epsabs
    real (kind=f) :: epsrel
    integer :: limit
    real (kind=f) :: result
    real (kind=f) :: abserr
    integer :: neval
    integer :: ier
    real (kind=f), dimension (limit) :: alist
    real (kind=f), dimension (limit) :: blist
    real (kind=f), dimension (limit) :: rlist
    real (kind=f), dimension (limit) :: elist
    integer, dimension (limit) :: iord
    integer :: last
    ! Calls: <A HREF="dqelg.html">dqelg</A>, <A HREF="dqk15i.html">dqk15i</A>, <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqagie
</PRE>
***begin prologue  dqagie
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a3a1,h2a4a1
***keywords  automatic integrator, infinite intervals,
             general-purpose, transformation, extrapolation,
             globally adaptive
***author  piessens,robert,appl. math & progr. div - k.u.leuven
           de doncker,elise,appl. math & progr. div - k.u.leuven
***purpose  the routine calculates an approximation result to a given
            integral   i = integral of f over (bound,+infinity)
            or i = integral of f over (-infinity,bound)
            or i = integral of f over (-infinity,+infinity),
            hopefully satisfying following claim for accuracy
            abs(i-result).le.max(epsabs,epsrel*abs(i))
***description
<P>
 integration over infinite intervals
 standard fortran subroutine
<P>
            fx     - double precision
                     function subprogram defining the integrand
                     function f(x). the actual name for f needs to be
                     declared e x t e r n a l in the driver program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
<P>
            bound  - double precision
                     finite bound of integration range
                     (has no meaning if interval is doubly-infinite)
<P>
            inf    - double precision
                     indicating the kind of integration range involved
                     inf = 1 corresponds to  (bound,+infinity),
                     inf = -1            to  (-infinity,bound),
                     inf = 2             to (-infinity,+infinity).
<P>
            epsabs - double precision
                     absolute accuracy requested
            epsrel - double precision
                     relative accuracy requested
                     if  epsabs.le.0
                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
                     the routine will end with ier = 6.
<P>
            limit  - integer
                     gives an upper bound on the number of subintervals
                     in the partition of (a,b), limit.ge.1
<P>
         on return
           result - double precision
                     approximation to the integral
<P>
            abserr - double precision
                     estimate of the modulus of the absolute error,
                     which should equal or exceed abs(i-result)
<P>
            neval  - integer
                     number of integrand evaluations
<P>
            ier    - integer
                     ier = 0 normal and reliable termination of the
                             routine. it is assumed that the requested
                             accuracy has been achieved.
                   <UL>
                   <LI>  ier.gt.0 abnormal termination of the routine. the
                             estimates for result and error are less
                             reliable. it is assumed that the requested
                             accuracy has not been achieved.
                   </UL>
            error messages
                     ier = 1 maximum number of subdivisions allowed
                             has been achieved. one can allow more
                             subdivisions by increasing the value of
                             limit (and taking the according dimension
                             adjustments into account). however,if
                             this yields no improvement it is advised
                             to analyze the integrand in order to
                             determine the integration difficulties.
                             if the position of a local difficulty can
                             be determined (e.g. singularity,
                             discontinuity within the interval) one
                             will probably gain from splitting up the
                             interval at this point and calling the
                             integrator on the subranges. if possible,
                             an appropriate special-purpose integrator
                             should be used, which is designed for
                             handling the type of difficulty involved.
                         = 2 the occurrence of roundoff error is
                             detected, which prevents the requested
                             tolerance from being achieved.
                             the error may be under-estimated.
                         = 3 extremely bad integrand behaviour occurs
                             at some points of the integration
                             interval.
                         = 4 the algorithm does not converge.
                             roundoff error is detected in the
                             extrapolation table.
                             it is assumed that the requested tolerance
                             cannot be achieved, and that the returned
                             result is the best which can be obtained.
                         = 5 the integral is probably divergent, or
                             slowly convergent. it must be noted that
                             divergence can occur with any other value
                             of ier.
                         = 6 the input is invalid, because
                             (epsabs.le.0 and
                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),
                             result, abserr, neval, last, rlist(1),
                             elist(1) and iord(1) are set to zero.
                             alist(1) and blist(1) are set to 0
                             and 1 respectively.
		             = 9 failure in sd1mach determining machine parameters
<P>
            alist  - double precision
                     vector of dimension at least limit, the first
                      last  elements of which are the left
                     end points of the subintervals in the partition
                     of the transformed integration range (0,1).
<P>
            blist  - double precision
                     vector of dimension at least limit, the first
                      last  elements of which are the right
                     end points of the subintervals in the partition
                     of the transformed integration range (0,1).
<P>
            rlist  - double precision
                     vector of dimension at least limit, the first
                      last  elements of which are the integral
                     approximations on the subintervals
<P>
            elist  - double precision
                     vector of dimension at least limit,  the first
                     last elements of which are the moduli of the
                     absolute error estimates on the subintervals
<P>
            iord   - integer
                     vector of dimension limit, the first k
                     elements of which are pointers to the
                     error estimates over the subintervals,
                     such that elist(iord(1)), ..., elist(iord(k))
                     form a decreasing sequence, with k = last
                     if last.le.(limit/2+2), and k = limit+1-last
                     otherwise
<P>
            last   - integer
                     number of subintervals actually produced
                     in the subdivision process
<P>
***references  (none)
***routines called  sd1mach,dqelg,dqk15i,dqpsrt
***end prologue  dqagie
<A NAME="subroutine_dqk15"><H3>dqk15</H3></A>
<PRE>private subroutine dqk15 (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk15
</PRE>
***begin prologue  dqk15
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a1a2
***keywords  15-point gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div - k.u.leuven
***purpose  to compute i = integral of f over (a,b), with error
                           estimate
                       j = integral of abs(f) over (a,b)
***description
<P>
           integration rules
           standard fortran subroutine
           double precision version
<P>
           parameters
            on entry
              fx     - double precision
                       function subprogram defining the integrand
                       function f(x). the actual name for f needs to be
                       declared e x t e r n a l in the calling program.
<P>
              fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code!
<P>
              a      - double precision
                       lower limit of integration
<P>
              b      - double precision
                       upper limit of integration
<P>
            on return
              result - double precision
                       approximation to the integral i
                       result is computed by applying the 15-point
                       kronrod rule (resk) obtained by optimal addition
                       of abscissae to the7-point gauss rule(resg).
<P>
              abserr - double precision
                       estimate of the modulus of the absolute error,
                       which should not exceed abs(i-result)
<P>
              resabs - double precision
                       approximation to the integral j
<P>
              resasc - double precision
                       approximation to the integral of abs(f-i/(b-a))
                       over (a,b)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk15  
<A NAME="subroutine_dqk21"><H3>dqk21</H3></A>
<PRE>private subroutine dqk21 (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk21
</PRE>
***begin prologue  dqk21
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a1a2
***keywords  21-point gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  to compute i = integral of f over (a,b), with error
                           estimate
                       j = integral of abs(f) over (a,b)
***description
<P>
           integration rules
           standard fortran subroutine
           double precision version
<P>
           parameters
            on entry
              fx     - double precision
                       function subprogram defining the integrand
                       function f(x). the actual name for f needs to be
                       declared e x t e r n a l in the driver program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
              a      - double precision
                       lower limit of integration
<P>
              b      - double precision
                       upper limit of integration
<P>
            on return
              result - double precision
                       approximation to the integral i
                       result is computed by applying the 21-point
                       kronrod rule (resk) obtained by optimal addition
                       of abscissae to the 10-point gauss rule (resg).
<P>
              abserr - double precision
                       estimate of the modulus of the absolute error,
                       which should not exceed abs(i-result)
<P>
              resabs - double precision
                       approximation to the integral j
<P>
              resasc - double precision
                       approximation to the integral of abs(f-i/(b-a))
                       over (a,b)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk21
<A NAME="subroutine_dqk31"><H3>dqk31</H3></A>
<PRE>private subroutine dqk31 (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk31
</PRE>
***begin prologue  dqk31
***date written   800101   (yymmdd)
***revision date  130519   (yymmdd)
***category no.  h2a1a2
***keywords  31-point gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  to compute i = integral of f over (a,b) with error
                           estimate
                       j = integral of abs(f) over (a,b)
***description
<P>
           integration rules
           standard fortran subroutine
           double precision version
<P>
           parameters
            on entry
              fx     - double precision
                       function subprogram defining the integrand
                       function f(x). the actual name for f needs to be
                       declared e x t e r n a l in the calling program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code!
<P>
              a      - double precision
                       lower limit of integration
<P>
              b      - double precision
                       upper limit of integration
<P>
            on return
              result - double precision
                       approximation to the integral i
                       result is computed by applying the 31-point
                       gauss-kronrod rule (resk), obtained by optimal
                       addition of abscissae to the 15-point gauss
                       rule (resg).
<P>
              abserr - double precison
                       estimate of the modulus of the modulus,
                       which should not exceed abs(i-result)
<P>
              resabs - double precision
                       approximation to the integral j
<P>
              resasc - double precision
                       approximation to the integral of abs(f-i/(b-a))
                       over (a,b)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk31
<A NAME="subroutine_dqk41"><H3>dqk41</H3></A>
<PRE>private subroutine dqk41 (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk41
</PRE>
***begin prologue  dqk41
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a1a2
***keywords  41-point gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  to compute i = integral of f over (a,b), with error
                           estimate
                       j = integral of abs(f) over (a,b)
***description
<P>
           integration rules
           standard fortran subroutine
           double precision version
<P>
           parameters
            on entry
              fx     - double precision
                       function subprogram defining the integrand
                       function f(x). the actual name for f needs to be
                       declared e x t e r n a l in the calling program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
<P>
              a      - double precision
                       lower limit of integration
<P>
              b      - double precision
                       upper limit of integration
<P>
            on return
              result - double precision
                       approximation to the integral i
                       result is computed by applying the 41-point
                       gauss-kronrod rule (resk) obtained by optimal
                       addition of abscissae to the 20-point gauss
                       rule (resg).
<P>
              abserr - double precision
                       estimate of the modulus of the absolute error,
                       which should not exceed abs(i-result)
<P>
              resabs - double precision
                       approximation to the integral j
<P>
              resasc - double precision
                       approximation to the integal of abs(f-i/(b-a))
                       over (a,b)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk41
<A NAME="subroutine_dqk51"><H3>dqk51</H3></A>
<PRE>private subroutine dqk51 (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk51
</PRE>
***begin prologue  dqk51
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a1a2
***keywords  51-point gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math & progr. div. - k.u.leuven
***purpose  to compute i = integral of f over (a,b) with error
                           estimate
                       j = integral of abs(f) over (a,b)
***description
<P>
           integration rules
           standard fortran subroutine
           double precision version
<P>
           parameters
            on entry
              fx     - double precision
                       function subroutine defining the integrand
                       function f(x). the actual name for f needs to be
                       declared e x t e r n a l in the calling program.
<P>
              fx_vars- structure containing variables need for integration
                       specific to fractal meanfield scattering code
<P>
              a      - double precision
                       lower limit of integration
<P>
              b      - double precision
                       upper limit of integration
<P>
            on return
              result - double precision
                       approximation to the integral i
                       result is computed by applying the 51-point
                       kronrod rule (resk) obtained by optimal addition
                       of abscissae to the 25-point gauss rule (resg).
<P>
              abserr - double precision
                       estimate of the modulus of the absolute error,
                       which should not exceed abs(i-result)
<P>
              resabs - double precision
                       approximation to the integral j
<P>
              resasc - double precision
                       approximation to the integral of abs(f-i/(b-a))
                       over (a,b)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk51
<A NAME="subroutine_dqk61"><H3>dqk61</H3></A>
<PRE>private subroutine dqk61 (fx, fx_vars, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk61
</PRE>
***begin prologue  dqk61
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a1a2
***keywords  61-point gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  to compute i = integral of f over (a,b) with error
                           estimate
                       j = integral of dabs(f) over (a,b)
***description
<P>
        integration rule
        standard fortran subroutine
        double precision version
<P>
        parameters
         on entry
           fx     - double precision
                    function subprogram defining the integrand
                    function f(x). the actual name for f needs to be
                    declared e x t e r n a l in the calling program.
<P>
            fx_vars- structure containing variables need for integration
                     specific to fractal meanfield scattering code
<P>
           a      - double precision
                    lower limit of integration
<P>
           b      - double precision
                    upper limit of integration
<P>
         on return
           result - double precision
                    approximation to the integral i
                    result is computed by applying the 61-point
                    kronrod rule (resk) obtained by optimal addition of
                    abscissae to the 30-point gauss rule (resg).
<P>
           abserr - double precision
                    estimate of the modulus of the absolute error,
                    which should equal or exceed dabs(i-result)
<P>
           resabs - double precision
                    approximation to the integral j
<P>
           resasc - double precision
                    approximation to the integral of dabs(f-i/(b-a))
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk61
<A NAME="subroutine_dqpsrt"><H3>dqpsrt</H3></A>
<PRE>private subroutine dqpsrt (limit, last, maxerr, ermax, elist, iord, nrmax)
    integer :: limit
    integer :: last
    integer :: maxerr
    real (kind=f) :: ermax
    real (kind=f), dimension (last) :: elist
    integer, dimension (last) :: iord
    integer :: nrmax
end subroutine dqpsrt
</PRE>
***begin prologue  dqpsrt
***refer to  dqage,dqagie,dqagpe,dqawse
***routines called  (none)
***revision date  130319   (yymmdd)
***keywords  sequential sorting
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  this routine maintains the descending ordering in the
            list of the local error estimated resulting from the
            interval subdivision process. at each call two error
            estimates are inserted using the sequential search
            method, top-down for the largest error estimate and
            bottom-up for the smallest error estimate.
***description
<P>
           ordering routine
           standard fortran subroutine
           double precision version
<P>
           parameters (meaning at output)
              limit  - integer
                       maximum number of error estimates the list
                       can contain
<P>
              last   - integer
                       number of error estimates currently in the list
<P>
              maxerr - integer
                       maxerr points to the nrmax-th largest error
                       estimate currently in the list
<P>
              ermax  - double precision
                       nrmax-th largest error estimate
                       ermax = elist(maxerr)
<P>
              elist  - double precision
                       vector of dimension last containing
                       the error estimates
<P>
              iord   - integer
                       vector of dimension last, the first k elements
                       of which contain pointers to the error
                       estimates, such that
                       elist(iord(1)),...,  elist(iord(k))
                       form a decreasing sequence, with
                       k = last if last.le.(limit/2+2), and
                       k = limit+1-last otherwise
<P>
              nrmax  - integer
                       maxerr = iord(nrmax)
<P>
***end prologue  dqpsrt
<A NAME="subroutine_dqk15i"><H3>dqk15i</H3></A>
<PRE>private subroutine dqk15i (fx, fx_vars, boun, inf, a, b, result, abserr, resabs, resasc, ier)
    interface fx
        function fx (centr, vars)
            real (kind=f), intent(in) :: centr
            type (adgaquad_vars_type), intent(inout) :: vars
            real (kind=f) :: fx
        end function fx
    end interface fx
    type (adgaquad_vars_type) :: fx_vars
    real (kind=f) :: boun
    integer :: inf
    real (kind=f) :: a
    real (kind=f) :: b
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f) :: resabs
    real (kind=f) :: resasc
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqk15i
</PRE>
***begin prologue  dqk15i
***date written   800101   (yymmdd)
***revision date  130319   (yymmdd)
***category no.  h2a3a2,h2a4a2
***keywords  15-point transformed gauss-kronrod rules
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math. & progr. div. - k.u.leuven
***purpose  the original (infinite integration range is mapped
            onto the interval (0,1) and (a,b) is a part of (0,1).
            it is the purpose to compute
            i = integral of transformed integrand over (a,b),
            j = integral of abs(transformed integrand) over (a,b).
***description
<P>
           integration rule
           standard fortran subroutine
           double precision version
<P>
           parameters
            on entry
              fx     - double precision
                       fuction subprogram defining the integrand
                       function f(x). the actual name for f needs to be
                       declared e x t e r n a l in the calling program.
<P>
              fx_vars- structure containing variables need for integration
                       specific to fractal meanfield scattering code!
<P>
              boun   - double precision
                       finite bound of original integration
                       range (set to zero if inf = +2)
<P>
              inf    - integer
                       if inf = -1, the original interval is
                                   (-infinity,bound),
                       if inf = +1, the original interval is
                                   (bound,+infinity),
                       if inf = +2, the original interval is
                                   (-infinity,+infinity) and
                       the integral is computed as the sum of two
                       integrals, one over (-infinity,0) and one over
                       (0,+infinity).
<P>
              a      - double precision
                       lower limit for integration over subrange
                       of (0,1)
<P>
              b      - double precision
                       upper limit for integration over subrange
                       of (0,1)
<P>
            on return
              result - double precision
                       approximation to the integral i
                       result is computed by applying the 15-point
                       kronrod rule(resk) obtained by optimal addition
                       of abscissae to the 7-point gauss rule(resg).
<P>
              abserr - double precision
                       estimate of the modulus of the absolute error,
                       which should equal or exceed abs(i-result)
<P>
              resabs - double precision
                       approximation to the integral j
<P>
              resasc - double precision
                       approximation to the integral of
                       abs((transformed integrand)-i/(b-a)) over (a,b)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***references  (none)
***routines called  sd1mach
***end prologue  dqk15i
<A NAME="subroutine_dqelg"><H3>dqelg</H3></A>
<PRE>private subroutine dqelg (n, epstab, result, abserr, res3la, nres, ier)
    integer :: n
    real (kind=f), dimension (52) :: epstab
    real (kind=f) :: result
    real (kind=f) :: abserr
    real (kind=f), dimension (3) :: res3la
    integer :: nres
    integer :: ier
    ! Calls: <A HREF="sd1mach.html">sd1mach</A>
end subroutine dqelg
</PRE>
***begin prologue  dqelg
***refer to  dqagie,dqagoe,dqagpe,dqagse
***routines called  sd1mach
***revision date  130319   (yymmdd)
***keywords  epsilon algorithm, convergence acceleration,
             extrapolation
***author  piessens,robert,appl. math. & progr. div. - k.u.leuven
           de doncker,elise,appl. math & progr. div. - k.u.leuven
***purpose  the routine determines the limit of a given sequence of
            approximations, by means of the epsilon algorithm of
            p.wynn. an estimate of the absolute error is also given.
            the condensed epsilon table is computed. only those
            elements needed for the computation of the next diagonal
            are preserved.
***description
<P>
           epsilon algorithm
           standard fortran subroutine
           double precision version
<P>
           parameters
              n      - integer
                       epstab(n) contains the new element in the
                       first column of the epsilon table.
<P>
              epstab - double precision
                       vector of dimension 52 containing the elements
                       of the two lower diagonals of the triangular
                       epsilon table. the elements are numbered
                       starting at the right-hand corner of the
                       triangle.
<P>
              result - double precision
                       resulting approximation to the integral
<P>
              abserr - double precision
                       estimate of the absolute error computed from
                       result and the 3 previous results
<P>
              res3la - double precision
                       vector of dimension 3 containing the last 3
                       results
<P>
              nres   - integer
                       number of calls to the routine
                       (should be zero at first call)
<P>
		  ier    - integer
                       ier = 0 normal and reliable termination of the
                               routine. it is assumed that the requested
                               accuracy has been achieved.
                       ier.gt.0 abnormal termination of the routine. the
                                estimates for result and error are less
                                reliable. it is assumed that the requested
                                accuracy has not been achieved.
<P>
***end prologue  dqelg
<A NAME="subroutine_sd1mach"><H3>SD1MACH</H3></A>
<PRE>private subroutine SD1MACH (I, D1MACH_OUT, IER)
    integer, INTENT(in) :: I
    real (kind=f), INTENT(out) :: D1MACH_OUT
    integer, INTENT(out) :: IER
    ! Calls: <A HREF="I1MCRY.html">I1MCRY</A>
end subroutine SD1MACH
</PRE>
 *********************************************************
 taken from BLAS library
  (http://netlib.bell-labs.com/netlib/blas)
 *********************************************************
<A NAME="subroutine_i1mcry"><H3>I1MCRY</H3></A>
<PRE>private subroutine I1MCRY (A, A1, B, C, D)
    integer :: A
    integer :: A1
    integer :: B
    integer :: C
    integer :: D
end subroutine I1MCRY
</PRE>
</HTML>
